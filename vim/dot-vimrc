" ----------------------------------------------------------------------------
"   .vimrc
" ----------------------------------------------------------------------------

set nocompatible " This must be first, because it changes other options
set redrawtime=5000
set lazyredraw
set backspace=indent,eol,start  " Backspace for dummies
set linespace=0                 " No extra spaces between rows
set number                      " Line numbers on
set showmatch                   " Show matching brackets/parenthesis
set incsearch                   " Find as you type search
set hlsearch                    " Highlight search terms
set winminheight=0              " Windows can be 0 line high
set ignorecase                  " Case insensitive search
set smartcase                   " Case sensitive when uc present
set wildmenu                    " Show list instead of just completing
set wildmode=list:longest,full  " Command <Tab> completion, list matches, then longest common part, then all.
set whichwrap=b,s,h,l,<,>,[,]   " Backspace and cursor keys wrap too
set scrolljump=5                " Lines to scroll when cursor leaves screen
set scrolloff=3                 " Minimum lines to keep above and below cursor
set foldenable                  " Auto fold code
set list
set listchars=tab:›\ ,trail:•,extends:#,nbsp:. " Highlight problematic whitespace
let mapleader = ','
set noswapfile
set backup
set nowb
set smc=10000
set autoread
set wrap
"set breakindent
set foldmethod=indent
set foldlevel=99
set smartindent
set smarttab
set shiftwidth=2
set softtabstop=2
set tabstop=2
set expandtab               " Create spaces when I type <tab>
set shiftround              " Round indent to multiple of 'shiftwidth'.
set autoindent              " Put my cursor in the right place when I start a new line
set laststatus=2            " The last window will have a status line always
set noshowmode              " Don't show the mode in the last line of the screen, vim-airline takes care of it
set ruler                   " Show the line and column number of the cursor position, separated by a comma.
"set rulerformat=%30(%=\:b%n%y%m%r%w\ %l,%c%V\ %P%) " A ruler on steroids
set showcmd                 " Show partial commands in status line and
set scrolloff=7             " Minimal number of screen lines to keep above and below the cursor.
"set visualbell              " Use a visual bell, don't beep!
set number                  " Show line numbers
set linebreak               " Break the line on words " this make syntastic extreme slow but now i'm using ale
"set cursorline                  " Highlight current line

" show fold column, fold by markers
set foldcolumn=0            " Don't show the folding gutter/column

" Open folds under the following conditions
set foldopen=block,hor,mark,percent,quickfix,search,tag,undo,jump

" Highlight tabs and trailing spaces

" Splits
set splitbelow              " Open new splits below
set splitright              " Open new vertical splits to the right
"set rtp+=/home/linuxbrew/.linuxbrew/opt/fzf



filetype plugin indent on   " Rely on file plugins to handle indenting
if has('clipboard')
    if has('unnamedplus')  " When possible use + register for copy-paste
        set clipboard=unnamed,unnamedplus
    else         " On mac and Windows, use * register for copy-paste
        set clipboard=unnamed
    endif
endif

syntax on                   " Syntax highlighting
set mouse=a                 " Automatically enable mouse usage
set mousehide               " Hide the mouse cursor while typing
scriptencoding utf-8
" switch to current directory
"autocmd BufEnter * if bufname("") !~ "^\[A-Za-z0-9\]*://" | lcd %:p:h | endif
let g:origdir = getcwd()
function! Auto_git_cd()
  try
    Gcd
  catch
    exe "cd" g:origdir
  endtry
endfunction
autocmd BufEnter * call Auto_git_cd()

set shortmess+=filmnrxoOtT          " Abbrev. of messages (avoids 'hit enter')
set viewoptions=folds,options,cursor,unix,slash " Better Unix / Windows compatibility
set virtualedit=onemore             " Allow for cursor beyond last character
set history=1000                    " Store a ton of history (default is 20)
"set spell                           " Spell checking on
set hidden                          " Allow buffer switching without saving
set iskeyword-=.                    " '.' is an end of word designator
set iskeyword-=#                    " '#' is an end of word designator
"set iskeyword-=-                    " '-' is an end of word designator
au FileType gitcommit au! BufEnter COMMIT_EDITMSG call setpos('.', [0, 1, 1, 0])
function! ResCur()
    if line("'\"") <= line("$")
        silent! normal! g`"
        return 1
    endif
endfunction

augroup resCur
    autocmd!
    autocmd BufWinEnter * call ResCur()
augroup END
set showmode                    " Display the current mode

highlight clear SignColumn      " SignColumn should match background
highlight clear LineNr          " Current line number row will have same background color in relative mode
" Selected characters/lines in visual mode
" ----------------------------------------------------------------------------
"
"   Search
" ----------------------------------------------------------------------------

" have x (removes single character) not go into the default registry
nnoremap x "_x
noremap j gj
noremap k gk
nnoremap <Leader>. :cd %:p:h<CR>:pwd<CR>
map <C-J> <C-W>j<C-W>_
map <C-K> <C-W>k<C-W>_
map <C-L> <C-W>l<C-W>_
map <C-H> <C-W>h<C-W>_
map <Leader>= <C-w>=
" Clear search highlights
nnoremap <leader>/ :set invhlsearch<cr>
map <leader>b :GFiles<cr>
map <C-p> :History<cr>

" Insert mode completion
imap <c-x><c-k> <plug>(fzf-complete-word)
imap <c-x><c-j> <plug>(fzf-complete-file-ag)
imap <c-x><c-l> <plug>(fzf-complete-line)
if &term =~ '^screen'
    " tmux knows the extended mouse mode
    set ttymouse=xterm2
endif

" Colors
syntax enable               " This has to come after colorcolumn in order to draw it.
set termguicolors     " enable true colors support


" When completing, fill with the longest common string
" Auto select the first option
set completeopt=longest,menuone

" Printing options
set printoptions=header:0,duplex:long,paper:letter,syntax:n
" header:0                  Do not print a header
" duplex:long (default)     Print on both sides (when possible), bind on long
" syntax:n                  Do not use syntax highlighting.

" -------------------------------------------------------------------------
"   Custom commands
" ----------------------------------------------------------------------------


" Trim trailing white space
nmap <silent> <Leader>t :call StripTrailingWhitespaces()<CR>
function! StripTrailingWhitespaces()
    let l = line(".")
    let c = col(".")
    %s/\s\+$//e
    call cursor(l, c)
endfun


" -------------------------------------------------------------------------}}}
"   Plugin
" ----------------------------------------------------------------------------
" Installing the Plug plugin manager, and all the plugins are included in this
" other file.
"
"
"let g:ale_disable_lsp = 1
source $HOME/.dotfiles/vim/plug.vim

" ----------------------------------------------------------------------------

set secure                      " disable unsafe commands in local .vimrc files

" Wildfire {
let g:wildfire_objects = {
            \ "*" : ["i'", 'i"', "i)", "i]", "i}", "ip"],
            \ "html,xml" : ["at"],
            \ }
" }
let g:fugitive_gitlab_domains = ['https://git.parcelperform.com']

" <Leader>f{char} to move to {char}
"map  <Leader><Leader>f <Plug>(easymotion-bd-f)
nmap <Leader>f <Plug>(easymotion-bd-f)

" s{char}{char} to move to {char}{char}
nmap <Leader>s <Plug>(easymotion-bd-f2)

" Move to line
"map <Leader><Leader>L <Plug>(easymotion-bd-jk)
"nmap <Leader><Leader>L <Plug>(easymotion-overwin-line)

"" Move to word
"map  <Leader><Leader>w <Plug>(easymotion-bd-w)
"nmap <Leader><Leader>w <Plug>(easymotion-overwin-w)
let g:vimwiki_list = [{'path': '~/vimwiki/',
                      \ 'syntax': 'markdown', 'ext': '.md'}]

nmap <silent> <Leader>ev :vsplit $MYVIMRC<CR>
nmap <silent> <Leader>ez :vsplit $HOME/.zshrc<CR>
map <silent> <Leader>ep :vsplit $HOME/dotfiles/vim/plug.vim<CR>
nmap <silent> <Leader>es :vsplit $HOME/.ssh/config<CR>
nmap <silent> <Leader>et :vsplit $HOME/.tmux.conf<CR>
nmap <silent> <Leader>sv :source $MYVIMRC<CR>
nmap <silent> <Leader>sp :source $HOME/.dotfiles/vim/plug.vim<CR>


" <Leader>f{char} to move to {char}
"nmap <Leader>f <Plug>(easymotion-bd-f)
-
" s{char}{char} to move to {char}{char}
"nmap <Leader>s <Plug>(easymotion-bd-f2)
let g:tslime_always_current_session = 1
let g:tslime_always_current_window = 1
let g:tslime_autoset_pane = 1
vmap <C-c><C-c> <Plug>SendSelectionToTmux
nmap <C-c>r <Plug>SetTmuxVars

let g:indent_guides_start_level = 2
let g:indent_guides_guide_size = 1
let g:indent_guides_enable_on_vim_startup = 1
let g:rainbow_active = 1
set wildignorecase
set wildignore+=*/.git,*/tmp/*,*.so,*.swp,*.zip     " MacOSX/Linux
" Don't offer to open certain files/directories
set wildignore+=*.bmp,*.gif,*.ico,*.jpg,*.png,*.ico
set wildignore+=*.pdf,*.psd
set wildignore+=node_modules/*,bower_components/*
set wildignore+=*/*.app/*

nnoremap <silent>* :let @/='\<<C-R>=expand("<cword>")<CR>\>'<CR>:set hls<CR>


" Character meaning when present in 'formatoptions'
" ------ ---------------------------------------
" c Auto-wrap comments using textwidth, inserting the current comment leader automatically.
" q Allow formatting of comments with "gq".
" r Automatically insert the current comment leader after hitting <Enter> in Insert mode.
" t Auto-wrap text using textwidth (does not apply to comments)
" n Recognize numbered lists
" 1 Don't break line after one-letter words
" a Automatically format paragraphs
set formatoptions=cqrn1

"jedi-vim
let g:jedi#popup_on_dot = 0
let g:jedi#popup_select_first=0
let g:jedi#completions_enabled = 0
let g:jedi#show_call_signatures = "0"
let g:jedi#rename_command = ""
let g:jedi#goto_stubs_command = ""

"let g:ale_python_flake8_executable = 'python'   " or 'python' for Python 2
"let g:ale_python_flake8_args = '-m flake8'

let g:ale_sign_warning = '▲'
let g:ale_sign_error = '✗'
highlight link ALEWarningSign String
highlight link ALEErrorSign Title

"let g:ale_completion_enabled = 1
let g:ale_lint_on_save = 1
let g:ale_lint_on_text_changed = 0
" You can disable this option too
" if you don't want linters to run on opening a file
let g:ale_lint_on_enter = 0
let g:ale_linters = {
\   'python': ['flake8']
"\   'rust': ['rls'],
\}

let g:ale_fixers = {
\   'python': ['black'],
\   'json': ['jq'],
\   'rust': ['rustfmt'],
\}
let g:ale_json_jsonlint_executable='jq'
let g:ale_python_flake8_options = '-m flake8'
let g:ale_python_black_options = '-S -l 119'
nmap <silent> <C-k> <Plug>(ale_previous_wrap)
nmap <silent> <C-j> <Plug>(ale_next_wrap)

function! Flake8(data)
  let g:ale_python_flake8_executable = a:data
  ALELint
endf
function! Flake()
  call Flake8('python3')
endf

" call ale check only when be called
command! -bar Python call Flake()

let g:ale_statusline_format = ['err %d', 'warn %d', '']

if executable('rg')
    " Use ag over grep
  set grepprg=rg\ --vimgrep

endif

"#exec  docker run -i --rm -v "$(pwd):/srv/pp_parser" --network parcel_perform --entrypoint pylint parcelperform/pp_parser:master "$@"
"docker exec -i pp_parser pylint "$@"
"if expand('%:p') =~# '^/home/andyhoang/test-pylint/'
    "let b:ale_linters = ['pylint']
    "let b:ale_python_pylint_use_global = 1
    "" This is the path to the script above.
    "let b:ale_python_pylint_executable = '/home/andyhoang/test-pylint/pylint.sh'
    "" /data matches the path in Docker.
    "let b:ale_filename_mappings = {
    "\ 'pylint': [
    "\   ['/home/andyhoang/test-pylint', '/srv/pp_parser'],
    "\ ],
    "\}
  "endif

" Undotree plugin.
nnoremap <F5> :UndotreeToggle<CR>

nmap <silent> <C-_> <Plug>(pydocstring)

let g:netrw_liststyle=0         " thin (change to 3 for tree)
let g:netrw_altv=1              " open files on right
let g:netrw_preview=0           " open previews vertically
let g:netrw_winsize = 25
let g:netrw_browse_split = 4


let vim_markdown_preview_github=1
let vim_markdown_preview_browser='Firefox'

let g:racer_cmd="/Users/andyhoang/.cargo/bin/racer"
let g:racer_experimental_completer = 1
au FileType rust nmap gd <Plug>(rust-def)
au FileType rust nmap gs <Plug>(rust-def-split)
au FileType rust nmap gx <Plug>(rust-def-vertical)
au FileType rust nmap <leader>gd <Plug>(rust-doc)


" -------------------------------------------------------------------------
"   Custom filetypes
" ----------------------------------------------------------------------------

" Auto detect filetype
autocmd BufRead,BufNewFile *.md,*.markdown set filetype=markdown
autocmd BufRead,BufNewFile *.md setlocal spell
autocmd FileType latex,tex,md,markdown setlocal spell
autocmd BufRead,BufNewFile *.lytex set filetype=tex
autocmd BufRead,BufNewFile ~/dotfiles/ssh/config set filetype=sshconfig
autocmd BufRead,BufNewFile *.git/config,.gitconfig,.gitmodules,gitconfig set ft=gitconfig
autocmd BufNewFile,BufRead *.html set filetype=htmldjango
autocmd BufNewFile,BufRead .eslintrc set filetype=javascript
autocmd BufRead,BufNewFile *.py setlocal foldmethod=indent

autocmd BufRead,BufNewFile *.scss set filetype=scss
autocmd FileType css setlocal omnifunc=csscomplete#CompleteCSS
autocmd FileType html,markdown setlocal omnifunc=htmlcomplete#CompleteTags
autocmd FileType javascript setlocal omnifunc=javascriptcomplete#CompleteJS
autocmd FileType python setlocal omnifunc=python3complete#Complete
"autocmd FileType python setlocal completeopt-=preview
autocmd FileType xml setlocal omnifunc=xmlcomplete#CompleteTags
autocmd FileType ruby setlocal omnifunc=rubycomplete#Complete
autocmd FileType haskell setlocal omnifunc=necoghc#omnifunc

autocmd FileType python UltiSnipsAddFiletypes django
" -------------------------------------------------------------------------
"   Custom mappings
" ----------------------------------------------------------------------------

" Make Y consistent with D
nnoremap Y y$

" Reselect visual block after indent/outdent: http://vimbits.com/bits/20
vnoremap < <gv
vnoremap > >gv
vnoremap = =gv



" Nobody ever uses "Ex" mode, and it's annoying to leave
noremap Q <nop>
let g:UltiSnipsExpandTrigger="<tab>"
let g:UltiSnipsListSnippets="\\<tab>"


function! InitializeDirectories()
    let parent = $HOME
    let prefix = 'vim'
    let dir_list = {
                \ 'backup': 'backupdir',
                \ 'views': 'viewdir',
                \ 'swap': 'directory' }

    if has('persistent_undo')
        let dir_list['undo'] = 'undodir'
        set undofile
        set undolevels=1000
        set undoreload=10000
    endif

    let common_dir = parent . '/.' . prefix

    for [dirname, settingname] in items(dir_list)
        let directory = common_dir . dirname . '/'
        if exists("*mkdir")
            if !isdirectory(directory)
                call mkdir(directory)
            endif
        endif
        if !isdirectory(directory)
            echo "Warning: Unable to create backup directory: " . directory
            echo "Try: mkdir -p " . directory
        else
            let directory = substitute(directory, " ", "\\\\ ", "g")
            exec "set " . settingname . "=" . directory
        endif
    endfor
endfunction
call InitializeDirectories()





" Return to last edit position when opening files, except git commit message
autocmd BufReadPost *
    \ if &ft != 'gitcommit' && line("'\"") > 0 && line("'\"") <= line("$") |
    \   exe "normal g`\"" |
    \ endif
    nnoremap Y y$

    " Code folding options
nmap <leader>f0 :set foldlevel=0<CR>
nmap <leader>f1 :set foldlevel=1<CR>
nmap <leader>f2 :set foldlevel=2<CR>
nmap <leader>f3 :set foldlevel=3<CR>
nmap <leader>f4 :set foldlevel=4<CR>
nmap <leader>f5 :set foldlevel=5<CR>
nmap <leader>f6 :set foldlevel=6<CR>
nmap <leader>f7 :set foldlevel=7<CR>
nmap <leader>f8 :set foldlevel=8<CR>
nmap <leader>f9 :set foldlevel=9<CR>


" use coc for jumps
"nmap <leader>d <Plug>(coc-definition)
"nmap <leader>gi <Plug>(coc-implementation)
"nmap <leader>gr <Plug>(coc-references)


" Use S_ to wrap a selection in gettext (Underscore tempalate style)
" Requires https://github.com/tpope/vim-surround
let b:surround_{char2nr('_')} = "<%- gettext(\"\r\") %>"

let g:jekyll_post_extension = '.md'

set exrc
"let g:tagbar_type_go = {
    "\ 'ctagstype' : 'go',
    "\ 'kinds'     : [
        "\ 'p:package',
        "\ 'i:imports:1',
        "\ 'c:constants',
        "\ 'v:variables',
        "\ 't:types',
        "\ 'n:interfaces',
        "\ 'w:fields',
        "\ 'e:embedded',
        "\ 'm:methods',
        "\ 'r:constructor',
        "\ 'f:functions'
    "\ ],
    "\ 'sro' : '.',
    "\ 'kind2scope' : {
        "\ 't' : 'ctype',
        "\ 'n' : 'ntype'
    "\ },
    "\ 'scope2kind' : {
        "\ 'ctype' : 't',
        "\ 'ntype' : 'n'
    "\ },
    "\ 'ctagsbin'  : 'gotags',
    "\ 'ctagsargs' : '-sort -silent'
"\ }


let g:lightline = {
      \ 'colorscheme': 'seoul256',
      \ 'active': {
      \   'left': [ [ 'mode', 'paste' ], [ 'fugitive', 'filename' ] ],
      \   'right': [ ['percent', 'linter_checking', 'linter_errors', 'linter_warnings', 'linter_ok'] ]
      \ },
      \ 'component_function': {
      \   'fugitive': 'LightlineFugitive',
      \   'filename': 'LightlineFilename',
      \   'fileformat': 'LightlineFileformat',
      \   'filetype': 'LightlineFiletype',
      \   'fileencoding': 'LightlineFileencoding',
      \   'mode': 'LightlineMode',
      \ },
      \ 'subseparator': { 'left': '|', 'right': '|' },
      \ 'component_expand':{
        \  'linter_checking': 'lightline#ale#checking',
        \  'linter_warnings': 'lightline#ale#warnings',
        \  'linter_errors': 'lightline#ale#errors',
        \  'linter_ok': 'lightline#ale#ok',
        "\  'coc': 'coc#status'
      \}
      \ }
function! LightlineModified()
  return &ft =~ 'help' ? '' : &modified ? '+' : &modifiable ? '' : '-'
endfunction

function! LightlineReadonly()
  return &ft !~? 'help' && &readonly ? 'RO' : ''
endfunction

function! LightlineFilename()
  let fname = expand('%:t')
  return fname == '__Tagbar__' ? g:lightline.fname :
        \ fname =~ '__Gundo\|NERD_tree' ? '' :
        \ &ft == 'vimfiler' ? vimfiler#get_status_string() :
        \ &ft == 'vimshell' ? vimshell#get_status_string() :
        \ ('' != LightlineReadonly() ? LightlineReadonly() . ' ' : '') .
        \ ('' != fname ? fname : '[No Name]') .
        \ ('' != LightlineModified() ? ' ' . LightlineModified() : '')
endfunction

function! LightlineFugitive()
  try
    if expand('%:t') !~? 'Tagbar\|Gundo\|NERD' && &ft !~? 'vimfiler' && exists('*fugitive#head')
      let mark = ''  " edit here for cool mark
      let branch = fugitive#head()
      return branch !=# '' ? mark.branch : ''
    endif
  catch
  endtry
  return ''
endfunction

function! LightlineFileformat()
  return winwidth(0) > 70 ? &fileformat : ''
endfunction

function! LightlineFiletype()
  return winwidth(0) > 70 ? (&filetype !=# '' ? &filetype : 'no ft') : ''
endfunction

function! LightlineFileencoding()
  return winwidth(0) > 70 ? (&fenc !=# '' ? &fenc : &enc) : ''
endfunction

function! LightlineMode()
  let fname = expand('%:t')
  return fname == '__Tagbar__' ? 'Tagbar' :
        \ fname == '__Gundo__' ? 'Gundo' :
        \ fname == '__Gundo_Preview__' ? 'Gundo Preview' :
        \ &ft == 'vimfiler' ? 'VimFiler' :
        \ &ft == 'vimshell' ? 'VimShell' :
        \ winwidth(0) > 60 ? lightline#mode() : ''
endfunction


let g:tagbar_status_func = 'TagbarStatusFunc'

function! TagbarStatusFunc(current, sort, fname, ...) abort
    let g:lightline.fname = a:fname
  return lightline#statusline(0)
endfunction


let g:gh_color = "soft"
set background=dark
colorscheme ghdark
"colorscheme material-theme
"colorscheme nord
"set t_Co=256

