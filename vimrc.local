"command Bd bp | sp | bn | bd
set noswapfile
set nobackup
set nowb
set autoread
set wrap
set linebreak
set breakindent
set showbreak=..
"colorscheme base16-railscasts
colorscheme gruvbox
set foldmethod=indent
set foldlevel=99
set smartindent
set smarttab
set shiftwidth=2
set softtabstop=2
set tabstop=2
"set wrapmargin=0
set noerrorbells visualbell t_vb=
set wildmode=longest,list,full
set wildmenu
set completeopt+=longest
autocmd GUIEnter * set visualbell t_vb=set nospell
let g:ctrlp_cmd = 'CtrlPMRU'
let g:jsbeautify_file = fnameescape(fnamemodify(expand("<sfile>"), ":h")."/bundle/js-beautify/beautify.js")
" Vim-Session Settings
let g:session_autosave = 'yes'
let g:session_autoload = 'yes'
let g:session_default_to_last = 1
let g:nerdtree_tabs_open_on_gui_startup = 0
set sessionoptions-=buffers
let g:session_autosave ='prompt'
let g:gruvbox_contrast_dark='soft'
set wildignore+=*/tmp/*,*.so,*.swp,*.zip     " MacOSX/Linux
""""""""""""""""""""""""""""""
" airline
""""""""""""""""""""""""""""""
"let g:airline_enable_syntastic  = 1
"let g:airline_theme='luna'
"let g:airline_powerline_fonts=1
"let g:airline_detect_modified=1
"let g:airline#extensions#branch#enabled=1
"let g:airline#extensions#syntastic#enabled=1
"let g:airline#extensions#tabline#enabled = 1
"let g:airline_mode_map = {
      "\ '__' : '-',
      "\ 'n'  : 'N',
      "\ 'i'  : 'I',
      "\ 'R'  : 'R',
      "\ 'c'  : 'C',
      "\ 'v'  : 'V',
      "\ 'V'  : 'V',
      "\ '' : 'V',
      "\ 's'  : 'S',
      "\ 'S'  : 'S',
      "\ '' : 'S',
      "\ }
let g:spf13_no_autochdir = 1

" syntastic
"let g:syntastic_disabled_filetypes=['elm']
"let g:syntastic_quiet_messages = { "type": "style" }
let g:syntastic_always_populate_loc_list = 1
let g:syntastic_auto_loc_list = 0
let g:syntastic_check_on_open = 0
let g:syntastic_check_on_wq = 0
let g:syntastic_html_checkers=['']
let g:syntastic_javascript_jshint_args = '--config ~/.jshintrc'
let g:syntastic_javascript_checkers = ['jshint']
"let g:syntastic_mode_map={'mode': 'active', 'passive_filetypes': ['haskell']}
let g:syntastic_python_checkers=['flake8']
"nmap <silent> <leader>hl :SyntasticCheck hlint<CR>:lopen<CR>
"set statusline+=%#warningmsg#
set statusline+=%{SyntasticStatuslineFlag()}
"set statusline+=%*

"youcompleteme
let g:ycm_auto_trigger = 0
let g:ycm_python_binary_path = 'python'

"Python-mode
"let g:pymode_rope_completion = 1
"jedi vim
let g:jedi#popup_on_dot = 0
let g:jedi#popup_select_first=0
"let g:jedi#show_call_signatures = 2
"let g:jedi#auto_initialization = 0
"let g:jedi#auto_vim_configuration = 0
"Haskell
"map <silent> tw :GhcModTypeInsert<CR>
"map <silent> ts :GhcModSplitFunCase<CR>
"map <silent> tq :GhcModType<CR>
"map <silent> te :GhcModTypeClear<CR>
"let g:necoghc_enable_detailed_browse = 1
"let g:haskellmode_completion_ghc = 0

" MatchTagAlways
let g:mta_use_matchparen_group = 0
"let g:formatter_yapf_style = 'facebook'

"Elm
"nnoremap <leader>el :ElmEvalLine<CR>
"vnoremap <leader>es :<C-u>ElmEvalSelection<CR>

" This is a Haskell configuration for the Vim Tagbar plugin that uses
" lushtags.
"
" Tagbar can be found at:
" http://www.vim.org/scripts/script.php?script_id=3465
" http://majutsushi.github.com/tagbar/
"
" Paste this in to your vimrc file
" OR copy this file into your .vim/plugin directory
" OR load it from your vimrc file by adding a line like:
"
" source /path/to/tagbar-haskell.vim

"if executable('lushtags')
    "let g:tagbar_type_haskell = {
        "\ 'ctagsbin' : 'lushtags',
        "\ 'ctagsargs' : '--ignore-parse-error --',
        "\ 'kinds' : [
            "\ 'm:module:0',
            "\ 'e:exports:1',
            "\ 'i:imports:1',
            "\ 't:declarations:0',
            "\ 'd:declarations:1',
            "\ 'n:declarations:1',
            "\ 'f:functions:0',
            "\ 'c:constructors:0'
        "\ ],
        "\ 'sro' : '.',
        "\ 'kind2scope' : {
            "\ 'd' : 'data',
            "\ 'n' : 'newtype',
            "\ 'c' : 'constructor',
            "\ 't' : 'type'
        "\ },
        "\ 'scope2kind' : {
            "\ 'data' : 'd',
            "\ 'newtype' : 'n',
            "\ 'constructor' : 'c',
            "\ 'type' : 't'
        "\ }
    "\ }
"endif
"
let g:tagbar_type_go = {
    \ 'ctagstype' : 'go',
    \ 'kinds'     : [
        \ 'p:package',
        \ 'i:imports:1',
        \ 'c:constants',
        \ 'v:variables',
        \ 't:types',
        \ 'n:interfaces',
        \ 'w:fields',
        \ 'e:embedded',
        \ 'm:methods',
        \ 'r:constructor',
        \ 'f:functions'
    \ ],
    \ 'sro' : '.',
    \ 'kind2scope' : {
        \ 't' : 'ctype',
        \ 'n' : 'ntype'
    \ },
    \ 'scope2kind' : {
        \ 'ctype' : 't',
        \ 'ntype' : 'n'
    \ },
    \ 'ctagsbin'  : 'gotags',
    \ 'ctagsargs' : '-sort -silent'
\ }

let g:lightline = {
      \ 'colorscheme': 'wombat',
      \ 'active': {
      \   'left': [ [ 'mode', 'paste' ], [ 'fugitive', 'filename' ], ['ctrlpmark'] ],
      \   'right': [ ['percent'] ]
      \ },
      \ 'component_function': {
      \   'fugitive': 'LightlineFugitive',
      \   'filename': 'LightlineFilename',
      \   'fileformat': 'LightlineFileformat',
      \   'filetype': 'LightlineFiletype',
      \   'fileencoding': 'LightlineFileencoding',
      \   'mode': 'LightlineMode',
      \   'ctrlpmark': 'CtrlPMark',
      \ },
      \ 'subseparator': { 'left': '|', 'right': '|' }
      \ }

function! LightlineModified()
  return &ft =~ 'help' ? '' : &modified ? '+' : &modifiable ? '' : '-'
endfunction

function! LightlineReadonly()
  return &ft !~? 'help' && &readonly ? 'RO' : ''
endfunction

function! LightlineFilename()
  let fname = expand('%:t')
  return fname == 'ControlP' && has_key(g:lightline, 'ctrlp_item') ? g:lightline.ctrlp_item :
        \ fname == '__Tagbar__' ? g:lightline.fname :
        \ fname =~ '__Gundo\|NERD_tree' ? '' :
        \ &ft == 'vimfiler' ? vimfiler#get_status_string() :
        \ &ft == 'unite' ? unite#get_status_string() :
        \ &ft == 'vimshell' ? vimshell#get_status_string() :
        \ ('' != LightlineReadonly() ? LightlineReadonly() . ' ' : '') .
        \ ('' != fname ? fname : '[No Name]') .
        \ ('' != LightlineModified() ? ' ' . LightlineModified() : '')
endfunction

function! LightlineFugitive()
  try
    if expand('%:t') !~? 'Tagbar\|Gundo\|NERD' && &ft !~? 'vimfiler' && exists('*fugitive#head')
      let mark = ''  " edit here for cool mark
      let branch = fugitive#head()
      return branch !=# '' ? mark.branch : ''
    endif
  catch
  endtry
  return ''
endfunction

function! LightlineFileformat()
  return winwidth(0) > 70 ? &fileformat : ''
endfunction

function! LightlineFiletype()
  return winwidth(0) > 70 ? (&filetype !=# '' ? &filetype : 'no ft') : ''
endfunction

function! LightlineFileencoding()
  return winwidth(0) > 70 ? (&fenc !=# '' ? &fenc : &enc) : ''
endfunction

function! LightlineMode()
  let fname = expand('%:t')
  return fname == '__Tagbar__' ? 'Tagbar' :
        \ fname == 'ControlP' ? 'CtrlP' :
        \ fname == '__Gundo__' ? 'Gundo' :
        \ fname == '__Gundo_Preview__' ? 'Gundo Preview' :
        \ fname =~ 'NERD_tree' ? 'NERDTree' :
        \ &ft == 'unite' ? 'Unite' :
        \ &ft == 'vimfiler' ? 'VimFiler' :
        \ &ft == 'vimshell' ? 'VimShell' :
        \ winwidth(0) > 60 ? lightline#mode() : ''
endfunction

function! CtrlPMark()
  if expand('%:t') =~ 'ControlP' && has_key(g:lightline, 'ctrlp_item')
    call lightline#link('iR'[g:lightline.ctrlp_regex])
    return lightline#concatenate([g:lightline.ctrlp_prev, g:lightline.ctrlp_item
          \ , g:lightline.ctrlp_next], 0)
  else
    return ''
  endif
endfunction

let g:ctrlp_status_func = {
  \ 'main': 'CtrlPStatusFunc_1',
  \ 'prog': 'CtrlPStatusFunc_2',
  \ }

function! CtrlPStatusFunc_1(focus, byfname, regex, prev, item, next, marked)
  let g:lightline.ctrlp_regex = a:regex
  let g:lightline.ctrlp_prev = a:prev
  let g:lightline.ctrlp_item = a:item
  let g:lightline.ctrlp_next = a:next
  return lightline#statusline(0)
endfunction

function! CtrlPStatusFunc_2(str)
  return lightline#statusline(0)
endfunction

let g:tagbar_status_func = 'TagbarStatusFunc'

function! TagbarStatusFunc(current, sort, fname, ...) abort
    let g:lightline.fname = a:fname
  return lightline#statusline(0)
endfunction

"augroup AutoSyntastic
  "autocmd!
  "autocmd BufWritePost *.py,*.js call s:syntastic()
"augroup END
"function! s:syntastic()
  "SyntasticCheck
  "call lightline#update()
"endfunction

let g:unite_force_overwrite_statusline = 0
"let g:vimfiler_force_overwrite_statusline = 0
"let g:vimshell_force_overwrite_statusline = 0
